/*
## Summary
Given a pre-generated file of UNE inputs (in the cloud), inject them into the core_assignments table.

Delete auto-generated UNE records from the core_assignments table
Append UNE-provided records to the core_assignments table

## Contacts
julian.tonti-filippini@curtin.edu.au

## License
Apache 2.0

## Requires
file gs://project-ries/tables/works_une/data*.jsonl

## Creates
table works_une

## Modified 
table core_assignments
*/
const UNE_ROR = "https://ror.org/04r659a56";
const compile = ({
  project = "",
  dataset = "",
  version = "",
  une_version = "",
  coki_project = "",
  coki_dataset = "",
  doi_table_version = "",
}) => `

-- generated by: ${require("path").basename(__filename)}

-- import UNE-provided data (see ../../jobs/UNE/patch_assignments/generate.js)
BEGIN
  LOAD DATA OVERWRITE \`${project}.${dataset}.raw_une_${version}\` (
    uuid          STRING  OPTIONS(description='universal unique ID'),
    output_type   STRING  OPTIONS(description=''),
    doi           STRING  OPTIONS(description='upper case DOI without the https://doi.org/'),
    url           STRING  OPTIONS(description='not used'),
    journal_issn  STRING  OPTIONS(description='UNE-provided ISSN (not used)'),
    journal_title STRING  OPTIONS(description='UNE-provided journal title (not used)'),
    for_count     INTEGER OPTIONS(description='number of codes for this work 1-3'),
    for1_code     STRING  OPTIONS(description='first FoR code'),
    for1_pct      INTEGER OPTIONS(description='first apportionment'),
    for2_code     STRING  OPTIONS(description='second FoR code'),
    for2_pct      INTEGER OPTIONS(description='third apportionment'),
    for3_code     STRING  OPTIONS(description='third FoR code'),
    for3_pct      INTEGER OPTIONS(description='third apportionment')
  )                       OPTIONS(description='UNE-provided assignments')
  FROM FILES (
    format = 'JSON',
    uris = ['gs://${project}-ries/data/tables/temp/une_outputs_${une_version}.jsonl']
  );

  -- check that fractions all sum to 100
  SELECT 'TEST: apportionment does not sum to 100', COUNT(1) AS tally FROM \`${project}.${dataset}.raw_une_${version}\` WHERE for1_pct + for2_pct + for3_pct != 100;

  -- check for empty DOIs
  SELECT 'TEST: empty DOI values', COUNT(1) AS tally FROM \`${project}.${dataset}.raw_une_${version}\` WHERE doi IS NULL OR doi = '';

  -- check for duplicated DOIs
  SELECT 'TEST: duplicated DOIs', COUNTIF(num > 1) AS tally FROM (
    SELECT COUNT(1) AS num FROM \`${project}.${dataset}.raw_une_${version}\` WHERE doi IS NOT NULL AND doi != '' GROUP BY doi
  );

  -- list duplicated DOIs
  SELECT doi, COUNT(1) AS num FROM \`${project}.${dataset}.raw_une_${version}\` WHERE doi IS NOT NULL AND doi != '' GROUP BY doi HAVING num > 1;

  -- check for non-articles
  SELECT 'TEST: non-articles', COUNT(1) AS tally FROM \`${project}.${dataset}.raw_une_${version}\` WHERE output_type != 'Article';

  -- count DOIs that are not found in COKI at all
  SELECT 
    'not found in COKI', COUNTIF(B.doi IS NULL) AS tally 
  FROM \`${project}.${dataset}.raw_une_${version}\` AS A
  LEFT JOIN ${coki_project}.${coki_dataset}.doi${doi_table_version} AS B ON UPPER(A.doi) = UPPER(B.doi)
  WHERE A.doi IS NOT NULL AND A.doi != '' AND A.output_type = 'Article';
  
  -- TODO: check that codes are in the ANZSRC2020 set
  -- TODO: check that codes are aligned with the ERA Journal List guidance

  -- distinct dois in the hand-curated set
  CREATE TEMP TABLE dois_hand AS (SELECT DISTINCT doi FROM \`${project}.${dataset}.raw_une_${version}\` WHERE doi IS NOT NULL AND doi != '' AND output_type = 'Article');

  -- distinct dois in the automatically generated set
  CREATE TEMP TABLE dois_auto AS (SELECT DISTINCT paper AS doi FROM \`${project}.${dataset}.core_assignments${version}\` WHERE LOWER(inst) = '${UNE_ROR}');

  -- distinct dois in the complete RIES set
  CREATE TEMP TABLE dois_ries AS (SELECT DISTINCT paper AS doi FROM \`${project}.${dataset}.core_assignments${version}\`);

  -- distinct dois between the une set and the auto set
  CREATE TEMP TABLE dois_hand_auto AS (SELECT A.doi FROM dois_hand AS A INNER JOIN dois_auto AS B ON A.doi = B.doi AND A.doi IS NOT NULL AND A.doi != '');
  
  -- distinct dois between the une set and the ries set
  CREATE TEMP TABLE dois_hand_ries AS (SELECT A.doi FROM dois_hand AS A INNER JOIN dois_ries AS B ON A.doi = B.doi AND A.doi IS NOT NULL AND A.doi != '');

  -- report on the counts
  SELECT 'distinct dois in the manually curated set'          , COUNT(1) AS tally FROM dois_hand;
  SELECT 'distinct dois in the automatically generated set'   , COUNT(1) AS tally FROM dois_auto;
  SELECT 'distinct dois in both the manual and automatic sets', COUNT(1) AS tally FROM dois_hand_auto;
  SELECT 'distinct dois in both the manual and ries sets'     , COUNT(1) AS tally FROM dois_hand_ries;

  -- filter the une-provided works table to only retain works that are found in core_papers (RIES filtered)
  CREATE TEMP TABLE une_works_filtered AS (
    SELECT
      A.*,
      B.doi            AS paper,
      B.year_published AS year,
      B.era_id         AS journal,
      B.num_citations  AS cits
    FROM \`${project}.${dataset}.raw_une_${version}\` AS A
    INNER JOIN \`${project}.${dataset}.core_papers${version}\` AS B ON UPPER(A.doi) = UPPER(B.doi)
  );

  -- expand the above into assignments
  CREATE TEMP TABLE une_assignments AS (
    WITH digit4 AS (
      SELECT
        year,
        journal,
        paper,
        cits,
        '${UNE_ROR}' AS inst,
        TRUE AS is_hep,
        field,
        SUBSTRING(field,0,2) AS field2,
        frac
      FROM (
        SELECT year, journal, paper, cits, for1_code AS field, for1_pct AS frac FROM une_works_filtered WHERE for1_pct > 0 UNION ALL
        SELECT year, journal, paper, cits, for2_code AS field, for2_pct AS frac FROM une_works_filtered WHERE for2_pct > 0 UNION ALL
        SELECT year, journal, paper, cits, for3_code AS field, for3_pct AS frac FROM une_works_filtered WHERE for3_pct > 0
      )
    ),
    digit2 AS (
      SELECT 
        year,
        journal,
        paper,
        cits,
        inst,
        is_hep,
        field2 AS field,
        field2,
        SUM(frac) AS frac
      FROM digit4 
      GROUP BY year, journal, paper, cits, inst, is_hep, field, field2
    )
    SELECT * FROM digit4
    UNION ALL
    SELECT * FROM digit2
    ORDER BY year,journal,paper,field
  );

  -- TODO: replace what follows with a more advanced conflict resolution process, such as 
  -- aggregating all apportionment claims between institutions, then normalising back to 100%.
  -- Currently, the way this works is to defer to UNE's apportionment claims wherever there is a 
  -- DOI being claimed by UNE. This means that UNE's apportionment will be applied to coauthoring
  -- institutions on that DOI.

  -- get a list of UNE papers (by DOI)
  CREATE TEMP TABLE une_papers AS (SELECT DISTINCT paper FROM une_assignments);

  -- get a list of coauthoring institutions according to the DOIs
  CREATE TEMP TABLE une_coauths AS (
    SELECT DISTINCT A.paper, A.inst, A.is_hep
    FROM \`${project}.${dataset}.core_assignments${version}\` AS A
    INNER JOIN une_papers AS B ON A.paper = B.paper AND A.inst != '${UNE_ROR}'
  );

  -- reassign apportionments
  CREATE TEMP TABLE reassigned AS (
    SELECT 
      B.year,
      B.journal,
      A.paper,
      B.cits,
      A.inst,
      A.is_hep,
      B.field,
      B.field2,
      B.frac
    FROM une_coauths AS A
    LEFT JOIN une_assignments AS B ON A.paper = B.paper
  );

  -- delete auto assignments that have anything to do with UNE
  DELETE FROM \`${project}.${dataset}.core_assignments${version}\` 
  WHERE LOWER(inst) = '${UNE_ROR}' OR paper IN (SELECT paper FROM une_papers);

  -- append the updated assignments that were provided by UNE
  INSERT INTO \`${project}.${dataset}.core_assignments${version}\`
       ( year,journal,paper,cits,inst,is_hep,field,field2,frac )
  SELECT year,journal,paper,cits,inst,is_hep,field,field2,frac FROM une_assignments UNION ALL 
  SELECT year,journal,paper,cits,inst,is_hep,field,field2,frac FROM reassigned;

END;
`;
const compile_all = (args = {}) => [compile(args)];
module.exports = { compile, compile_all };
if (require.main === module) {
  require("app").cli_compile(compile_all);
}
